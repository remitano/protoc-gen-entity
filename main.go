package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// basicGoType maps a scalar FieldDescriptor to its Go type.
func basicGoType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

// goTypeForField determines the Go type for a given protogen.Field.
func goTypeForField(field *protogen.Field) string {
	// Handle map<key,value>
	if field.Desc.IsMap() {
		keyDesc := field.Desc.MapKey()
		valDesc := field.Desc.MapValue()
		keyType := basicGoType(keyDesc)
		valType := basicGoType(valDesc)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	name := string(field.Desc.Name())
	var baseType string

	if strings.HasSuffix(name, "_scaled") {
		baseType = "*big.Int"
	} else {
		switch field.Desc.Kind() {
		case protoreflect.MessageKind:
			entityName := field.Message.GoIdent.GoName + "Entity"
			baseType = "*" + entityName

		case protoreflect.BoolKind:
			baseType = "bool"
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
			baseType = "int32"
		case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
			baseType = "int64"
		case protoreflect.FloatKind:
			baseType = "float32"
		case protoreflect.DoubleKind:
			baseType = "float64"
		case protoreflect.StringKind:
			baseType = "string"
		case protoreflect.BytesKind:
			baseType = "[]byte"
		default:
			baseType = "interface{}"
		}
	}

	// Nếu là repeated field thì chuyển thành slice
	if field.Desc.IsList() {
		return "[]" + baseType
	}
	return baseType
}

// needsBigIntImport returns true if any field requires math/big.
func needsBigIntImport(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if strings.HasSuffix(string(field.Desc.Name()), "_scaled") {
				return true
			}
		}
	}
	return false
}

// hasFieldId checks if message has "id" field.
func hasFieldId(message *protogen.Message) bool {
	for _, field := range message.Fields {
		if string(field.Desc.Name()) == "id" {
			return true
		}
	}
	return false
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			// Generate main entity file
			filename := f.GeneratedFilenamePrefix + ".go"
			g := plugin.NewGeneratedFile(filename, f.GoImportPath)

			g.P("// Code generated by protoc-gen-entity-v2. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()

			// Imports
			g.P("import (")
			if needsBigIntImport(f) {
				g.P(`    "math/big"`)
			}
			g.P(`    "trading.engine/go_services/pkg/streams/core"`)
			g.P(")")
			g.P()

			// Generate code per message
			for _, message := range f.Messages {
				structName := message.GoIdent.GoName + "Entity"
				pbType := message.GoIdent.GoName

				// Struct definition
				g.P("type ", structName, " struct {")
				for _, field := range message.Fields {
					goType := goTypeForField(field)
					jsonTag := fmt.Sprintf("`json:\"%s\"`", field.Desc.JSONName())
					g.P("    ", field.GoName, " ", goType, " ", jsonTag)
				}
				g.P("}")
				g.P()

				// Getter methods
				for _, field := range message.Fields {
					methodName := fmt.Sprintf("Get%s", field.GoName)
					goType := goTypeForField(field)
					g.P("func (a *", structName, ") ", methodName, "() ", goType, " {")
					g.P("    return a.", field.GoName)
					g.P("}")
					g.P()
				}

				// FromPB
				g.P("func (a *", structName, ") FromPB(pb core.DataMessage) {")
				g.P("    in := pb.(*", pbType, ")")
				for _, field := range message.Fields {
					fieldName := field.GoName
					if field.Desc.IsMap() {
						g.P("    if len(in.", fieldName, ") > 0 {")
						g.P("        a.", fieldName, " = make(", goTypeForField(field), ", len(in.", fieldName, "))")
						g.P("        for k, v := range in.", fieldName, " {")
						g.P("            a.", fieldName, "[k] = v")
						g.P("        }")
						g.P("    }")
					} else if strings.HasSuffix(string(field.Desc.Name()), "_scaled") {
						g.P("    if in.", fieldName, " != \"\" {")
						g.P("        if val, ok := new(big.Int).SetString(in.", fieldName, ", 10); ok {")
						g.P("            a.", fieldName, " = val")
						g.P("        }")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(field), ", len(in.", fieldName, "))")
							g.P("        for i, v := range in.", fieldName, " {")
							g.P("            e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("            e.FromPB(v)")
							g.P("            a.", fieldName, "[i] = e")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if in.", fieldName, " != nil {")
							g.P("        e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("        e.FromPB(in.", fieldName, ")")
							g.P("        a.", fieldName, " = e")
							g.P("    }")
						}
					} else {
						g.P("    a.", fieldName, " = in.", fieldName)
					}
				}
				g.P("}")
				g.P()

				// ToProtoBuf
				g.P("func (a *", structName, ") ToProtoBuf() core.DataMessage {")
				g.P("    out := &", pbType, "{}")
				for _, field := range message.Fields {
					fieldName := field.GoName
					if field.Desc.IsMap() {
						g.P("    if len(a.", fieldName, ") > 0 {")
						g.P("        out.", fieldName, " = make(", goTypeForField(field), ", len(a.", fieldName, "))")
						g.P("        for k, v := range a.", fieldName, " {")
						g.P("            out.", fieldName, "[k] = v")
						g.P("        }")
						g.P("    }")
					} else if strings.HasSuffix(string(field.Desc.Name()), "_scaled") {
						g.P("    if a.", fieldName, " != nil {")
						g.P("        out.", fieldName, " = a.", fieldName, ".String()")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make([]*", field.Message.GoIdent.GoName, ", len(a.", fieldName, "))")
							g.P("        for i, e := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[i] = e.ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if a.", fieldName, " != nil {")
							g.P("        out.", fieldName, " = a.", fieldName, ".ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("    }")
						}
					} else {
						g.P("    out.", fieldName, " = a.", fieldName)
					}
				}
				g.P("    return out")
				g.P("}")
				g.P()

				// Extension file generation (.ext.go)
				extFileName := f.GeneratedFilenamePrefix + ".ext.go"
				ext := plugin.NewGeneratedFile(extFileName, f.GoImportPath)
				ext.P("package ", f.GoPackageName)
				ext.P()
				// IdempotencyType only when message has 'id' field
				ext.P("func (a *", structName, ") IdempotencyType() string {")
				ext.P("    return \"", message.GoIdent.GoName, "\"")
				ext.P("}")
				ext.P()
				// IdempotencyValue always generated; returns a.Id if exists, otherwise -1
				ext.P("func (a *", structName, ") IdempotencyValue() int64 {")
				if hasFieldId(message) {
					ext.P("    return a.Id")
				} else {
					ext.P("    return int64(-1)")
				}
				ext.P("}")
			}
		}
		return nil
	})
}
