package main

import (
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	opt := protogen.Options{}
	opt.Run(func(plugin *protogen.Plugin) error {
		useSourceRelative := strings.Contains(plugin.Request.GetParameter(), "paths=source_relative")

		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			var filenameBase string
			if useSourceRelative {
				filenameBase = file.GeneratedFilenamePrefix
			} else {
				filenameBase = string(file.GoImportPath) + "/" + file.GeneratedFilenamePrefix
			}

			entityFilename := filenameBase + "_entity.go"
			testFilename := filenameBase + "_entity_test.go"

			entity := plugin.NewGeneratedFile(entityFilename, file.GoImportPath)
			test := plugin.NewGeneratedFile(testFilename, file.GoImportPath)

			entity.P("// Code generated by protoc-gen-entity. DO NOT EDIT.")
			entity.P("package ", file.GoPackageName)
			entity.P()

			test.P("package ", file.GoPackageName)
			test.P()
			test.P("import (")
			test.P(`"testing"`)
			test.P(`"github.com/stretchr/testify/assert"`)
			test.P(`pb "`, string(file.GoImportPath), `"`)
			test.P(")")
			test.P()

			for _, message := range file.Messages {
				protoName := message.GoIdent.GoName
				entityName := protoName + "Entity"

				// Entity struct
				entity.P("type ", entityName, " struct {")
				for _, field := range message.Fields {
					goName := title(field.GoName)
					goType := fieldGoType(field)
					jsonTag := "`json:\"" + field.Desc.JSONName() + "\"`"
					entity.P(goName, " ", goType, " ", jsonTag)
				}
				entity.P("}")
				entity.P()

				// ToProto
				entity.P("func (e *", entityName, ") ToProto() *", protoName, " {")
				entity.P("  if e == nil { return nil }")
				entity.P("  return &", protoName, "{")
				for _, field := range message.Fields {
					f := title(field.GoName)
					if isNumeric(field) {
						entity.P("    ", f, ": ", castNumeric("e."+f, field), ",")
					} else {
						entity.P("    ", f, ": e.", f, ",")
					}
				}
				entity.P("  }")
				entity.P("}")
				entity.P()

				// FromProto
				entity.P("func FromProto", protoName, "(pb *", protoName, ") *", entityName, " {")
				entity.P("  if pb == nil { return nil }")
				entity.P("  return &", entityName, "{")
				for _, field := range message.Fields {
					f := title(field.GoName)
					if isNumeric(field) {
						entity.P("    ", f, ": ", castNumeric("pb."+f, field), ",")
					} else {
						entity.P("    ", f, ": pb." + f + ",")
					}
				}
				entity.P("  }")
				entity.P("}")
				entity.P()

				// Unit tests
				test.P("func Test", entityName, "_ToProto(t *testing.T) {")
				test.P("  entity := &", entityName, "{")
				for _, field := range message.Fields {
					fieldName := title(field.GoName)
					test.P("    ", fieldName, ": ", exampleValue(field), ",")
				}
				test.P("  }")
				test.P("  pb := entity.ToProto()")
				for _, field := range message.Fields {
					fieldName := title(field.GoName)
					test.P("  assert.Equal(t, entity.", fieldName, ", pb.", fieldName, ")")
				}
				test.P("}")
				test.P()

				test.P("func TestFromProto", protoName, "(t *testing.T) {")
				test.P("  pb := &pb.", protoName, "{")
				for _, field := range message.Fields {
					fieldName := title(field.GoName)
					test.P("    ", fieldName, ": ", exampleValue(field), ",")
				}
				test.P("  }")
				test.P("  entity := FromProto", protoName, "(pb)")
				for _, field := range message.Fields {
					fieldName := title(field.GoName)
					test.P("  assert.Equal(t, pb.", fieldName, ", entity.", fieldName, ")")
				}
				test.P("}")
				test.P()
			}
		}
		return nil
	})
}

func title(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func fieldGoType(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.BoolKind:
		return "bool"
	default:
		return "interface{}"
	}
}

func isNumeric(field *protogen.Field) bool {
	switch field.Desc.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind:
		return true
	default:
		return false
	}
}

func castNumeric(value string, field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32(" + value + ")"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64(" + value + ")"
	case protoreflect.FloatKind:
		return "float32(" + value + ")"
	case protoreflect.DoubleKind:
		return "float64(" + value + ")"
	default:
		return value
	}
}

func exampleValue(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return `"test"`
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "123"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "123456789"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return "123.45"
	case protoreflect.BoolKind:
		return "true"
	default:
		return "nil"
	}
}
