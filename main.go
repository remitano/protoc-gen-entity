package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func goTypeForField(field *protogen.Field) string {
	name := string(field.Desc.Name())
	if strings.HasSuffix(name, "_scaled") {
		return "*big.Int"
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "*" + string(field.Message.GoIdent.GoName)
	default:
		return "interface{}"
	}
}

func needsBigIntImport(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if strings.HasSuffix(string(field.Desc.Name()), "_scaled") {
				return true
			}
		}
	}
	return false
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			filename := f.GeneratedFilenamePrefix + ".go"
			g := plugin.NewGeneratedFile(filename, f.GoImportPath)

			g.P("// Code generated by protoc-gen-entity-v2. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()

			// Imports
			g.P("import (")
			if needsBigIntImport(f) {
				g.P(`    "math/big"`)
			}
			g.P(`    "trading.engine/go_services/pkg/streams/core"`)
			g.P(")")
			g.P()

			for _, message := range f.Messages {
				structName := message.GoIdent.GoName + "Entity"
				pbType := message.GoIdent.GoName

				// Struct
				g.P("type ", structName, " struct {")
				for _, field := range message.Fields {
					goType := goTypeForField(field)
					jsonTag := fmt.Sprintf("`json:\"%s\"`", field.Desc.JSONName())
					g.P("\t", field.GoName, " ", goType, " ", jsonTag)
				}
				g.P("}")
				g.P()

				// Getter methods
				for _, field := range message.Fields {
					methodName := fmt.Sprintf("Get%s", field.GoName)
					goType := goTypeForField(field)
					g.P("func (a *", structName, ") ", methodName, "() ", goType, " {")
					g.P("\treturn a.", field.GoName)
					g.P("}")
					g.P()
				}

				// FromPB
				g.P("func (a *", structName, ") FromPB(pb core.DataMessage) {")
				g.P("\tin := pb.(*", pbType, ")")
				for _, field := range message.Fields {
					fieldName := field.GoName
					protoName := string(field.Desc.Name())
					if strings.HasSuffix(protoName, "_scaled") {
						g.P("\tif in.", fieldName, " != \"\" {")
						g.P("\t\tif val, ok := new(big.Int).SetString(in.", fieldName, ", 10); ok {")
						g.P("\t\t\ta.", fieldName, " = val")
						g.P("\t\t}")
						g.P("\t}")
					} else {
						g.P("\ta.", fieldName, " = in.", fieldName)
					}
				}
				g.P("}")
				g.P()

				// ToProtoBuf
				g.P("func (a *", structName, ") ToProtoBuf() core.DataMessage {")
				g.P("\tout := &", pbType, "{}")
				for _, field := range message.Fields {
					fieldName := field.GoName
					protoName := string(field.Desc.Name())
					if strings.HasSuffix(protoName, "_scaled") {
						g.P("\tif a.", fieldName, " != nil {")
						g.P("\t\tout.", fieldName, " = a.", fieldName, ".String()")
						g.P("\t}")
					} else {
						g.P("\tout.", fieldName, " = a.", fieldName)
					}
				}
				g.P("\treturn out")
				g.P("}")
				g.P()
			}
		}
		return nil
	})
}
