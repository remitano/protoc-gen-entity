package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func resolveImportPath(goImportPath protogen.GoImportPath, newSuffix string) string {
	path := string(goImportPath)

	schemaIndex := strings.Index(path, "/pkg/")
	if schemaIndex == -1 {
		return path
	}

	prefix := path[:schemaIndex] // ví dụ: github.com/remitano/azasend-za-be
	return prefix + "/" + newSuffix
}

func basicGoType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.BytesKind:
		return "*uint256.Int"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	default:
		return "interface{}"
	}
}

func goTypeForField(g *protogen.GeneratedFile, field *protogen.Field) string {
	name := string(field.Desc.Name())
	// map field
	if field.Desc.IsMap() {
		keyDesc := field.Desc.MapKey()
		keyType := basicGoType(keyDesc)
		valDesc := field.Desc.MapValue()

		// special case: map<string, google.protobuf.Timestamp>
		if valDesc.Kind() == protoreflect.MessageKind &&
			valDesc.Message().FullName() == "google.protobuf.Timestamp" {
			return fmt.Sprintf("map[%s]*time.Time", keyType)
		}

		if strings.HasSuffix(name, "_by_provider") || strings.HasSuffix(name, "_amount_scaled_map") || strings.HasSuffix(name, "_amount_e18_map") {
			return fmt.Sprintf("map[%s]*uint256.Int", keyType)
		}

		valType := basicGoType(valDesc)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	// enum field (non-map)
	if field.Desc.Kind() == protoreflect.EnumKind {
		baseType := g.QualifiedGoIdent(field.Enum.GoIdent)
		if field.Desc.IsList() {
			return "[]" + baseType
		}
		return baseType
	}

	var baseType string

	// message field
	if field.Desc.Kind() == protoreflect.MessageKind {
		if field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" ||
			field.Message.Desc.FullName() == "google.protobuf.Timestamp" {
			baseType = "*time.Time"
		} else {
			entityName := field.Message.GoIdent.GoName + "Entity"
			baseType = "*" + entityName
		}
	} else {
		baseType = basicGoType(field.Desc)
	}

	if field.Desc.IsList() {
		return "[]" + baseType
	}
	return baseType
}

func needsUint256Import(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if strings.HasSuffix(string(field.Desc.Name()), "_by_provider") ||
				field.Desc.Kind() == protoreflect.BytesKind ||
				isBytesMapWithE18OrScaled(field) {
				return true
			}
		}
	}
	return false
}

func needsTimeImport(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind &&
				(field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" ||
					field.Message.Desc.FullName() == "google.protobuf.Timestamp") {
				return true
			}
			if field.Desc.IsMap() {
				valDesc := field.Desc.MapValue()
				if valDesc.Kind() == protoreflect.MessageKind &&
					valDesc.Message().FullName() == "google.protobuf.Timestamp" {
					return true
				}
			}
		}
	}
	return false
}

func hasFieldId(message *protogen.Message) bool {
	for _, field := range message.Fields {
		if string(field.Desc.Name()) == "id" {
			return true
		}
	}
	return false
}

// isBytesMapWithE18OrScaled checks if field is a map<string, bytes> and field name contains "E18" or "Scaled"
func isBytesMapWithE18OrScaled(field *protogen.Field) bool {
	if !field.Desc.IsMap() {
		return false
	}

	// Check if map value is bytes
	valDesc := field.Desc.MapValue()
	if valDesc.Kind() != protoreflect.BytesKind {
		return false
	}

	// Check if field name contains "E18" or "Scaled"
	fieldName := string(field.Desc.Name())
	return strings.Contains(fieldName, "E18") || strings.Contains(fieldName, "Scaled")
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			filename := f.GeneratedFilenamePrefix + ".go"
			g := plugin.NewGeneratedFile(filename, f.GoImportPath)

			g.P("// Code generated by protoc-gen-entity-v2. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()

			g.P("import (")
			g.P(`    "fmt"`)
			g.P(`    "strings"`)

			if needsUint256Import(f) {
				g.P(`    "github.com/holiman/uint256"`)
			}
			if needsTimeImport(f) {
				g.P(`    "time"`)
				g.P(`    "google.golang.org/protobuf/types/known/timestamppb"`)
			}
			coreImport := resolveImportPath(f.GoImportPath, "pkg/streams/core")
			g.P(`    "`, coreImport, `"`)
			g.P(")")
			g.P()

			for _, message := range f.Messages {
				structName := message.GoIdent.GoName + "Entity"
				pbType := message.GoIdent.GoName

				// struct
				g.P("type ", structName, " struct {")
				for _, field := range message.Fields {
					var tag string
					// if goType == "*uint256.Int" {
					//   tag = fmt.Sprintf("`json:\"%s\" fake:\"{uint256ptr}\"`", field.Desc.JSONName())
					// } else {
					tag = fmt.Sprintf("`json:\"%s\"`", field.Desc.JSONName())
					// }
					goType := goTypeForField(g, field)
					g.P("    ", field.GoName, " ", goType, " ", tag)
				}
				g.P("}")
				g.P()

				// Get<Field>()
				for _, field := range message.Fields {
					methodName := fmt.Sprintf("Get%s", field.GoName)
					goType := goTypeForField(g, field)
					g.P("func (a *", structName, ") ", methodName, "() ", goType, " {")
					g.P("    return a.", field.GoName)
					g.P("}")
					g.P()
				}

				// FromPB
				g.P("func (a *", structName, ") FromPB(pb core.DataMessage) {")
				g.P("    in := pb.(*", pbType, ")")
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						if isBytesMapWithE18OrScaled(field) {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(map[string]*uint256.Int, len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = new(uint256.Int).SetBytes(v)")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "_amount_scaled_map") || strings.HasSuffix(fieldJSON, "_amount_e18_map") {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(map[string]*uint256.Int, len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = new(uint256.Int).SetBytes(v)")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_updated_at_map") {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(g, field), ", len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = v.AsTime()")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(g, field), ", len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = v")
							g.P("        }")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    a.", fieldName, " = new(uint256.Int)")
						g.P("    if in.", fieldName, " != nil {")
						g.P("        a.", fieldName, ".SetBytes(in.", fieldName, ")")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind &&
						field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" {
						g.P("    if in.", fieldName, " != nil {")
						g.P("        t := in.", fieldName, ".AsTime()")
						g.P("        a.", fieldName, " = &t")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(g, field), ", len(in.", fieldName, "))")
							g.P("        for i, v := range in.", fieldName, " {")
							g.P("            e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("            e.FromPB(v)")
							g.P("            a.", fieldName, "[i] = e")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if in.", fieldName, " != nil {")
							g.P("        e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("        e.FromPB(in.", fieldName, ")")
							g.P("        a.", fieldName, " = e")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.EnumKind {
						// pb field đã là đúng enum type -> assign thẳng
						g.P("    a.", fieldName, " = in.", fieldName)
					} else {
						g.P("    a.", fieldName, " = in.", fieldName)
					}
				}
				g.P("}")
				g.P()

				// ToProtoBuf
				g.P("func (a *", structName, ") ToProtoBuf() core.DataMessage {")
				g.P("    out := &", pbType, "{}")
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						if isBytesMapWithE18OrScaled(field) {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(map[string][]byte, len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = v.Bytes()")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "_amount_scaled_map") || strings.HasSuffix(fieldJSON, "_amount_e18_map") {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(map[string][]byte, len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = v.Bytes()")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_updated_at_map") {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(", goTypeForField(g, field), ", len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = timestamppb.New(*v)")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(", goTypeForField(g, field), ", len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = v")
							g.P("        }")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    if a.", fieldName, " != nil {")
						g.P("        out.", fieldName, " = a.", fieldName, ".Bytes()")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind &&
						field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" {
						g.P("    if a.", fieldName, " != nil {")
						g.P("        out.", fieldName, " = timestamppb.New(*a.", fieldName, ")")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make([]*", field.Message.GoIdent.GoName, ", len(a.", fieldName, "))")
							g.P("        for i, e := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[i] = e.ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if a.", fieldName, " != nil {")
							g.P("        out.", fieldName, " = a.", fieldName, ".ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.EnumKind {
						// enum type khớp pb -> assign thẳng
						g.P("    out.", fieldName, " = a.", fieldName)
					} else {
						g.P("    out.", fieldName, " = a.", fieldName)
					}
				}
				g.P("    return out")
				g.P("}")
				g.P()

				// String()
				g.P("func (a *", structName, ") String() string {")
				g.P("    var builder strings.Builder")
				g.P(`    builder.WriteString("`, structName, ` {\n")`)
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						g.P("    if a.", fieldName, " != nil {")
						g.P(`        builder.WriteString("  `, fieldName, `: {\n")`)
						g.P("        for k, v := range a.", fieldName, " {")
						if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "map") {
							g.P("            if v != nil {")
							g.P(`                builder.WriteString(fmt.Sprintf("    %s: %s,\\n", k, v.String()))`)
							g.P("            } else {")
							g.P(`                builder.WriteString(fmt.Sprintf("    %s: nil,\\n", k))`)
							g.P("            }")
						} else {
							g.P(`            builder.WriteString(fmt.Sprintf("    %s: %v,\\n", k, v))`)
						}
						g.P("        }")
						g.P(`        builder.WriteString("  },\n")`)
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    if a.", fieldName, " != nil {")
						g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %s,\\n", a.`, fieldName, `.String()))`)
						g.P("    } else {")
						g.P(`        builder.WriteString("  `, fieldName, `: nil,\\n")`)
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
						} else {
							g.P("    if a.", fieldName, " != nil {")
							g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
							g.P("    } else {")
							g.P(`        builder.WriteString("  `, fieldName, `: nil,\\n")`)
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.EnumKind {
						g.P(`    builder.WriteString(fmt.Sprintf("  `, fieldName, `: %s,\n", a.`, fieldName, `.String()))`)
					} else {
						g.P(`    builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
					}
				}
				g.P(`    builder.WriteString("}")`)
				g.P("    return builder.String()")
				g.P("}")
				g.P()

				// ext file
				extFile := f.GeneratedFilenamePrefix + ".ext.go"
				ext := plugin.NewGeneratedFile(extFile, f.GoImportPath)
				ext.P("package ", f.GoPackageName)
				ext.P()
				eventTypeConst := "EventType" + structName[:len(structName)-len("EventEntity")]
				ext.P(`func (a *`, structName, `) IdempotencyType() string {`)
				ext.P(`	return `, eventTypeConst)
				ext.P(`}`)
				ext.P()
				ext.P("func (a *", structName, ") IdempotencyValue() int64 {")
				if hasFieldId(message) {
					ext.P("    return a.Id")
				} else {
					ext.P("    return int64(-1)")
				}
				ext.P("}")
				ext.P()
				ext.P(`// IsValid implements backward compatibility with legacy code`)
				ext.P(`func (a *`, structName, `) IsValid() bool {`)
				ext.P(`	valid, _ := a.IsValidWithReason()`)
				ext.P(`	return valid`)
				ext.P(`}`)
				ext.P()
				ext.P(`// IsValidWithReason provides detailed validation with error reasons`)
				ext.P(`// TODO: Implement proper validation logic based on business requirements`)
				ext.P(`func (a *`, structName, `) IsValidWithReason() (bool, string) {`)
				ext.P(`	// Add validation logic here, for example:`)
				ext.P(`	// if a.Id == 0 {`)
				ext.P(`	//     return false, "Id is zero"`)
				ext.P(`	// }`)
				ext.P(`	// if a.Symbol == "" {`)
				ext.P(`	//     return false, "Symbol is empty"`)
				ext.P(`	// }`)
				ext.P(`	return true, ""`)
				ext.P(`}`)
				ext.P()
				ext.P(`func (a *`, structName, `) PartitionKey() string {`)
				ext.P(`	return fixMe`)
				ext.P(`}`)
			}
		}
		return nil
	})
}
