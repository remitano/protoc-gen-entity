package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func resolveImportPath(goImportPath protogen.GoImportPath, newSuffix string) string {
	path := string(goImportPath)

	schemaIndex := strings.Index(path, "/pkg/")
	if schemaIndex == -1 {
		return path
	}

	prefix := path[:schemaIndex] // ví dụ: github.com/remitano/azasend-za-be
	return prefix + "/" + newSuffix
}

func basicGoType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.BytesKind:
		return "*uint256.Int"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	default:
		return "interface{}"
	}
}

func goTypeForField(field *protogen.Field) string {
	name := string(field.Desc.Name())
	if field.Desc.IsMap() {
		keyDesc := field.Desc.MapKey()
		keyType := basicGoType(keyDesc)
		valDesc := field.Desc.MapValue()

		// special case: map<string, google.protobuf.Timestamp>
		if valDesc.Kind() == protoreflect.MessageKind &&
			valDesc.Message().FullName() == "google.protobuf.Timestamp" {
			return fmt.Sprintf("map[%s]*time.Time", keyType)
		}

		if strings.HasSuffix(name, "_by_provider") || strings.HasSuffix(name, "_amount_scaled_map") {
			return fmt.Sprintf("map[%s]*uint256.Int", keyType)
		}

		valType := basicGoType(valDesc)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	var baseType string

	if field.Desc.Kind() == protoreflect.MessageKind {
		if field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" ||
			field.Message.Desc.FullName() == "google.protobuf.Timestamp" {
			baseType = "*time.Time"
		} else {
			entityName := field.Message.GoIdent.GoName + "Entity"
			baseType = "*" + entityName
		}
	} else {
		baseType = basicGoType(field.Desc)
	}

	if field.Desc.IsList() {
		return "[]" + baseType
	}
	return baseType
}

func needsUint256Import(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if strings.HasSuffix(string(field.Desc.Name()), "_by_provider") || field.Desc.Kind() == protoreflect.BytesKind {
				return true
			}
		}
	}
	return false
}

func needsTimeImport(file *protogen.File) bool {
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind &&
				(field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" ||
					field.Message.Desc.FullName() == "google.protobuf.Timestamp") {
				return true
			}
			if field.Desc.IsMap() {
				valDesc := field.Desc.MapValue()
				if valDesc.Kind() == protoreflect.MessageKind &&
					valDesc.Message().FullName() == "google.protobuf.Timestamp" {
					return true
				}
			}
		}
	}
	return false
}

func hasFieldId(message *protogen.Message) bool {
	for _, field := range message.Fields {
		if string(field.Desc.Name()) == "id" {
			return true
		}
	}
	return false
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			filename := f.GeneratedFilenamePrefix + ".go"
			g := plugin.NewGeneratedFile(filename, f.GoImportPath)

			g.P("// Code generated by protoc-gen-entity-v2. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()

			g.P("import (")
			g.P(`    "fmt"`)
			g.P(`    "strings"`)

			if needsUint256Import(f) {
				g.P(`    "github.com/holiman/uint256"`)
			}
			if needsTimeImport(f) {
				g.P(`    "time"`)
				g.P(`    "google.golang.org/protobuf/types/known/timestamppb"`)
			}
			coreImport := resolveImportPath(f.GoImportPath, "pkg/streams/core")
			g.P(`    "`, coreImport, `"`)
			g.P(")")
			g.P()

			for _, message := range f.Messages {
				structName := message.GoIdent.GoName + "Entity"
				pbType := message.GoIdent.GoName

				// struct
				g.P("type ", structName, " struct {")
				for _, field := range message.Fields {
					goType := goTypeForField(field)
					var tag string
					if goType == "*uint256.Int" {
						tag = fmt.Sprintf("`json:\"%s\" fake:\"{uint256ptr}\"`", field.Desc.JSONName())
					} else {
						tag = fmt.Sprintf("`json:\"%s\"`", field.Desc.JSONName())
					}
					g.P("    ", field.GoName, " ", goType, " ", tag)
				}
				g.P("}")
				g.P()

				// Get<Field>()
				for _, field := range message.Fields {
					methodName := fmt.Sprintf("Get%s", field.GoName)
					goType := goTypeForField(field)
					g.P("func (a *", structName, ") ", methodName, "() ", goType, " {")
					g.P("    return a.", field.GoName)
					g.P("}")
					g.P()
				}

				// FromPB
				g.P("func (a *", structName, ") FromPB(pb core.DataMessage) {")
				g.P("    in := pb.(*", pbType, ")")
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "_amount_scaled_map") {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(map[string]*uint256.Int, len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = new(uint256.Int).SetBytes(v)")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_updated_at_map") {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(field), ", len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = v.AsTime()")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(field), ", len(in.", fieldName, "))")
							g.P("        for k, v := range in.", fieldName, " {")
							g.P("            a.", fieldName, "[k] = v")
							g.P("        }")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    a.", fieldName, " = new(uint256.Int)")
						g.P("    if in.", fieldName, " != nil {")
						g.P("        a.", fieldName, ".SetBytes(in.", fieldName, ")")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind &&
						field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" {
						g.P("    if in.", fieldName, " != nil {")
						g.P("        t := in.", fieldName, ".AsTime()")
						g.P("        a.", fieldName, " = &t")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(in.", fieldName, ") > 0 {")
							g.P("        a.", fieldName, " = make(", goTypeForField(field), ", len(in.", fieldName, "))")
							g.P("        for i, v := range in.", fieldName, " {")
							g.P("            e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("            e.FromPB(v)")
							g.P("            a.", fieldName, "[i] = e")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if in.", fieldName, " != nil {")
							g.P("        e := &", field.Message.GoIdent.GoName, "Entity{}")
							g.P("        e.FromPB(in.", fieldName, ")")
							g.P("        a.", fieldName, " = e")
							g.P("    }")
						}
					} else {
						g.P("    a.", fieldName, " = in.", fieldName)
					}
				}
				g.P("}")
				g.P()

				// ToProtoBuf
				g.P("func (a *", structName, ") ToProtoBuf() core.DataMessage {")
				g.P("    out := &", pbType, "{}")
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "_amount_scaled_map") {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(map[string][]byte, len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = v.Bytes()")
							g.P("        }")
							g.P("    }")
						} else if strings.HasSuffix(fieldJSON, "_updated_at_map") {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(", goTypeForField(field), ", len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = timestamppb.New(*v)")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make(", goTypeForField(field), ", len(a.", fieldName, "))")
							g.P("        for k, v := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[k] = v")
							g.P("        }")
							g.P("    }")
						}
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    if a.", fieldName, " != nil {")
						g.P("        out.", fieldName, " = a.", fieldName, ".Bytes()")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind &&
						field.Message.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/timestamppb" {
						g.P("    if a.", fieldName, " != nil {")
						g.P("        out.", fieldName, " = timestamppb.New(*a.", fieldName, ")")
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P("    if len(a.", fieldName, ") > 0 {")
							g.P("        out.", fieldName, " = make([]*", field.Message.GoIdent.GoName, ", len(a.", fieldName, "))")
							g.P("        for i, e := range a.", fieldName, " {")
							g.P("            out.", fieldName, "[i] = e.ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("        }")
							g.P("    }")
						} else {
							g.P("    if a.", fieldName, " != nil {")
							g.P("        out.", fieldName, " = a.", fieldName, ".ToProtoBuf().(*", field.Message.GoIdent.GoName, ")")
							g.P("    }")
						}
					} else {
						g.P("    out.", fieldName, " = a.", fieldName)
					}
				}
				g.P("    return out")
				g.P("}")
				g.P()

				// String()
				g.P("func (a *", structName, ") String() string {")
				g.P("    var builder strings.Builder")
				g.P(`    builder.WriteString("`, structName, ` {\n")`)
				for _, field := range message.Fields {
					fieldName := field.GoName
					fieldJSON := string(field.Desc.Name())

					if field.Desc.IsMap() {
						g.P("    if a.", fieldName, " != nil {")
						g.P(`        builder.WriteString("  `, fieldName, `: {\n")`)
						g.P("        for k, v := range a.", fieldName, " {")
						if strings.HasSuffix(fieldJSON, "_by_provider") || strings.HasSuffix(fieldJSON, "map") {
							g.P("            if v != nil {")
							g.P(`                builder.WriteString(fmt.Sprintf("    %s: %s,\\n", k, v.String()))`)
							g.P("            } else {")
							g.P(`                builder.WriteString(fmt.Sprintf("    %s: nil,\\n", k))`)
							g.P("            }")
						} else {
							g.P(`            builder.WriteString(fmt.Sprintf("    %s: %v,\\n", k, v))`)
						}
						g.P("        }")
						g.P(`        builder.WriteString("  },\n")`)
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.BytesKind {
						g.P("    if a.", fieldName, " != nil {")
						g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %s,\\n", a.`, fieldName, `.String()))`)
						g.P("    } else {")
						g.P(`        builder.WriteString("  `, fieldName, `: nil,\\n")`)
						g.P("    }")
					} else if field.Desc.Kind() == protoreflect.MessageKind {
						if field.Desc.IsList() {
							g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
						} else {
							g.P("    if a.", fieldName, " != nil {")
							g.P(`        builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
							g.P("    } else {")
							g.P(`        builder.WriteString("  `, fieldName, `: nil,\\n")`)
							g.P("    }")
						}
					} else {
						g.P(`    builder.WriteString(fmt.Sprintf("  `, fieldName, `: %v,\\n", a.`, fieldName, `))`)
					}
				}
				g.P(`    builder.WriteString("}")`)
				g.P("    return builder.String()")
				g.P("}")
				g.P()

				// ext file
				extFile := f.GeneratedFilenamePrefix + ".ext.go"
				ext := plugin.NewGeneratedFile(extFile, f.GoImportPath)
				ext.P("package ", f.GoPackageName)
				ext.P()
				eventTypeConst := "EventType" + structName[:len(structName)-len("EventEntity")]
				ext.P(`func (a *`, structName, `) IdempotencyType() string {`)
				ext.P(`	return `, eventTypeConst)
				ext.P(`}`)
				ext.P()
				ext.P("func (a *", structName, ") IdempotencyValue() int64 {")
				if hasFieldId(message) {
					ext.P("    return a.Id")
				} else {
					ext.P("    return int64(-1)")
				}
				ext.P("}")
			}
		}
		return nil
	})
}
